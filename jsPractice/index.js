// 데이터 타입
/*
자바스크립트는 7개의 데이터 타입을 제공
원시타입 과 객체타입으로 분류
--원시타입
number : 숫자와 정수와 실수 구분없이 하나의 숫자 타입만 존재
String : 문자열
Boolean : 논리적 참 거짓
undifind : var 키워드로 선언된 뱐수에 암묵적으로 할당되는 값
null : 값이 없다는 것을 의도적으로 명시할때 사용하는 값
symbol : 추가된 7번째 타입
--객체타입
객체 함수 배열 등

숫자타입의 값과 문자열의 값은 다르다 1, '1' 은 다르다

숫자 타입 c 나 자바의 경우 int,long,float,double 등과 같은 다양한 숫자타입을 제공하지만 자바스크립트는 하나의 숫자타입만 존재한다
모든 수를 실수로만 처리하며, 정수로 표현하기 위한 데이터 타입이 별도로 존재하지 않음
*/

var integer = 10; //정수
var double = 10.12; //실수
var negative = -20; // 음의 정수

// 모두 10진수로 해석된다.

var binary = ob01000001; // 2진수
var octal = 0o101;       // 8진수
var hex = 0x41;          // 16진수

console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // ture
console.log(octal===hex); // ture

// 자바스크립트의 숫자 티입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다고 했다, 이는 정수로 표시된다 해도 사실은
// 실수라는 것을 의미 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올수 없다

console.log(1 === 1.0) //true
console.log(4 / 2) //2
console.log(3 / 2) //1.5

// 숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.
/*
 Infinity : 양의 무한대
 -Infinity : 음의 무한대
 NaN : 산술 연산 불가 (not - a - number)
*/

console.log(10/0); // infinity
console.log(10/-0); // -infinity
console.log(1*'String'); // infinity

// 자바스크립트 엔진은 대소문자 구별 다르게 작성하면 식별자로 구별한다

var string = hello; // ReferenceError : hello is not defind 
// 만약 따옴표로 문자열을 감싸지 않는다면 스페이스 와 같은 공백 문자도 포함시킬수 없다

/* 탬플릿 리터럴

탬플릿 리터럴 문자열 표현식 삽입 태그드 템플릿 등 편리한 문자열 처리기능을 제공, 템플릿 리터럴은 런터임에 일반 문자열로 전환한다
작은따옴표 큰따옴표 같은 일반적인 따옴표 대신 백틱(``)을사용 
*/

var template = `Template literal`;
console.log(template); // Template literal

// 멀티라인 문자열 
// 일반 문자열 내에서는 줄바꿈 이 허용되지 않는다

//var str = 'Hello
//world.'; SyntaxError : Invalid or unexpected token

// 따라서 일반 문자열 내에서 줄바꿈 등의 공백 을 표현하려면 백슬래시로 시작하는 이스케이프 시퀸스를 사용해야한다.

// 표현식 삽입

var first = 'ung-mo';
var last = 'Lee';

console.log('my name is' + first+` `+ last+`.`) // my name ius ungmo lee.

// 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할수 있다, 이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할수 있다.

console.log(`1+2=${1+2}`) // 1+2 = 3
console.log('1+2=${1+2}') // 1+2 = ${1+2}

// 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야한다 템플릿 리터럴이 아닌 일반 문자열어세의 표현식 삽입은 문자열로 취급한다.
// 자바스크립트를 이루고 있는 거의 모든것이 객체라는 것
// 자바스크립트는 개발자의 의도와는 상관없으 자바스크립트 엔진에 의해 임묵적으로 타입이 자동으로 변환된다
// 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 만든다 결국 동적 타입언어는 유연성은 높지만 신뢰도가 떨어진다

/*
1.변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수 갓을 재할당에 의해 언제든지 변경될수 았다. 변수의 무분별한 남발은 금지이며 필요한만큼
최소한으로 유지하도록 한다
2. 변수의 유혀 범위(스코프) 는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 변수의 유효 범위가 넓으면 넓을수록 변수로 인해
오류가 발생할 확률이 높아진다. 
3. 전역변수는 최대한 사용하지 않는다 어디서든지 변경/참조가 가능하기에 의도치 않은 변경될 가능성이 높아 다른코드에도 영향을 줄수있다
따라서 전역변수는 프로그램에 복잡성을 증가시키고 처리흐름을 추적하기 어렵기 때문에 오류의 원인또한 찾기 힘들다
4. 변수보다는 상수를 사용해 값의 변경을 억제한다. 
5. 변수의 이름은 변수의 목적이나 의미를 파악할수 있도록 네이밍한다. 특히 식별자의 유효 범위가 넓을수록 명확한 이름을 명명하도록 노력한다
개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들고 협업과 생산성에 영향을 준다 변수의 이름은 첫아이 이름을 짓듯이
신중하게 지어야 한다.

코드는 오햐하지 않도록 주의 해야한다, 오해는 커뮤니케이션을 어렵게 하는 대푝적인 원인으로 생산성을 떨어트리는 것은 물론 팀의 사기까지 저하기킨다
코드는 동작하는 것만이 존재 목적은 아니다 코드는 개발자를 위한 문서이기도 하다, 사람이 이해할수 있는 코드 가독성이 좋은코드가 좋은 코드다.

true 는 1로 할당
false 는 1로 할당
null 은 0으로 할당
undefind 는 숫자로 타입을 변환하지 않는다.

*/

// 연쇄 할당
a=b=c=0 
// 여러 변수에 동일한 값을 할당할수도 있다

/*
 == 동등비교 x==y x와 y의 값이 같음
 === 일치비교 x===y x와 y의 타입이 같음
 != 부등호 비교 x!=y x와 y의 값이 다름
 !== 불일치 비교 x!==y x와 y의 타입이 다름

 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환되기도 한다 이를 암묵적 변환이라 한다
 동등 비교(==) 연산자는 좌항가 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다
 동등 비교 연산자는 좌항과 우항의 타입이 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true 를 반환한다
// 동등비교 
5=='5'; true
5== 5   true

 동등 비교 연산자는 예측하기 어려운 결과를 만들어 낸다 따라서 동등비교 연산자는 사용하지 않는 편이 좋고 대신 일치비교(===) 연산자를 사용
 일치비교(===) 연산자는 좌항가 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다 다시 말해 암묵적 타입 변환을 하지 않고 값을 비교한다
 따라서 일치 비교 연산자는 예측하기 쉽다

 5===5 true
 5==='5' false

 NaN === NaN NaN 은 자신과 일치하지 않는 유일한 값이다
 isNaN(NaN) true
 isNaN(10) false
 inNaN(1+undefined); true
 숫자 0도 주의하자 자바스크립트에 양의0과 음의 0이있는 이들을 비교하면 true 로 반환한다
 0 === -0 true
 0 == -0 true
*/

// 삼항 조건 연산자
/*
    삼항 조건 연산자는 조건식의 평가 결과에 따라 반환값을 결정한다 자바스크립트의 유일한 삼항 연산자이며, 부수효과는 없다

    (score >= 60) === false
    var result = score >= 60 ?'pass':'fail';
    (score >= 60) === true

    삼항 조건 연산자는 첫 번째 피연산자가 true로 평가되면 두 번째 피 연산자를 반환하고, 첫 번째 피연산자가 false 로 평가되면
    세 번째 피연산자를 반환한다 즉 삼항 조건 연산자는 두 번째 파연산자가 또는 세 번째 피연산자로 평가되는 표현식이다
    만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다, 이때 조건식이 참이면 콜론(:) 앞의 두번째의
    피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤에 세번째 피연산자가 반환된다.
*/

// 7-21
var x =2;
// 2%2 는 0이고 0은 false로 암묵적 타입변환이 된다.
var result = x%2 ?'홀수':'짝수';
console.log(x) //짝수

// 7-22
// 삼항 조건 연산자의 첫 번째 피연산자는 조건식이므로 삼항 조건 연산자 표현식은 조건문이다. if else 문을 사용해 삼항 조건 연산자 
// 표현식과 유사하게 처리 할수 있다
var x = 2, result;
// 2 % 2 는 0이고 false 로 암묵적 타입 변환된다.
if(x%2) result = '홀수';
else    result = '짝수';
console.log(result)

/*하지만 삼항 조건 연산자 표현식은 if else 문과 중요한 차이가 있다, 삼항 조건 연산자 표현식은 값처럼 사용할순 있지만
if else 문은 값처럼 사용할수 없다*/

//7-23
var x = 10;
// if else 문은 표현식이 아닌 문이다 따라서 값처럼 사용할 수 없다.
//var result = if(x%2){result='홀수';} else{result='짝수';};
// 삼항 조건 연산자 표현식은 값으로 평가할수 있는 표현식인 문이다. 삼항 조건 연산자 표현식은 값처럼 다른 표현식의 일부가 될수있어
// 매우 유용하다.

//7-24
var x=10;
// 삼항 조건 ㅇ연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할수 있다
var result = x%2 ? '홀수' : '짝수';
console.log(result) //짝수
// 조건에 따라 어떤 값을 결정해야 한다면 if else 문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다 하지만 조건에 따라 수행해야 할
// 문이 하나가 아니라 여러 개라면 if else 문의 가독성이 더 좋다

