// 지수 연산자

2**2; //4
2**2.5; // 5.656854
2**0; // 1
2**-2; // 0.25

// 지수 연산자는 Math.pow 매서드 보다 가독성이 좋다

2**2**2 // 16
Math.pow(Math.pow(2,2),2); //16
//음수를 거듭제곱의 밑으로 계산하려면 다음과 같이 괄호로 묶어야 한다
(-5)**2; //25
// 지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할수 있다
var num=5
num**=2 //25
// 지수 연산자는 이항 연산자 중에서 우선쉰위가 가장 높다.
2*5**2 // 50

// 대부분의 연산자는 다른 코드에 영향을 주지 않는다 예를 들어 1 * 2 는 다른 코드에 영향을 주지 않고 새로운 값 2를 생성할뿐이다
// 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다
// 부수 효과가 있는 연산자(=),증가 감소 연산자(++/--), delete 연산자 이다

var x; // 할당 연산자는 변수 값이 변하는 부수 효과가 있다 이는 x는 변수를 사용하는 다른 코드에 영향을 준다
x++ // 피연산자 x 의 값이 재할당되어 변경된다, 이는 x변수를 사용하는 다른 코드에 영향을 준다
var o ={a:1};
// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다 이는 o 객체를 사용하는 다른 코드에 영향을 준다
delete o.a
console.log(o); //{}

// 연산자의 우선 순위
/*
1.()
2.new(매개변수 존재),[]프로퍼티 접근,()함수호출,?(옵셔널 체이닝 연산자)
3.new(매개변수 미존재)
4.x++,x--
5.!x,+x,-x,++x,--x,typeof,delete
6.** (이항 연산자 중에서 우선순위가 가장 높다)
7. *,/,%
8. +,-
9. <,<=,>,>=,in,instanceof
10, ==,!=,===,!==
11. ??(병합연산자)
12. &&
13. ||
14. ? ...:...
15. 할당 연산자(+,+=,-=,...)
16. ,
연산자는 종류가 많아서 연산자 우선순위를 모두 기억하기 어렵고 실수하기도 쉽다 따라서 기억에 의존하기 보다는 연산자 우선순위가 가장 노은 그룹 연산자를
사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.
// 그룹 연산자를 사용하여 우선순위를 명시적으로 조절 
*/

10*(2+3); // 50

// 연산자 결합 순서
// 연산자 결합 순서란 연산자의 어느쪽 부터 평가를 수행할 것인지를 나타내는 순서를 말한다 연산자의 결합 순서는 다음과 같다
/*
좌항 > 우항 : +,-,/,%,<,<=,>,>=,&&,||,.,[],(),??,?.,in instanceof
우항 > 좌항 : ++,--,할당 연산자(=,+=,-=,...),!x,+x,-x,++x,--x,typeof,delete,? ...:...
*/

// 제어문
// 제어문을 사용하면 코드를 인위적으로 제어할수 있다 다만 실행 순성가 변경된다는 것은 단순히 위에서 아랴로 순차적으로 진행하는 직관적인
// 코드의 흐름을 혼란스럽게 한다 가독성을 떨어트린다 가독성이 좋지않은 코드는 오류를 발생시키는 오류가 된다 

// 불록문은 0개 이상의 문을 중괄호로 묶은 것으로 코드 불록 또는 블록이라고 부르기도 한다 자바스크립트는 블록문을 하나의 실행단위로 취급한다
// 불록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다 
// 불록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 불록문의 끝에는 세미클론을 붙이지 않는다

// 불록문 예제
{
    var foo =10;
}
// 제어문
var x = 1;
if(x<10){
    x++;
}
// 함수 선언문
function sum(a,b){
    return a+b;    
}

// if else 문은 줘진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과 즉 논리적 참 또는 거짓에 따란
// 실행할 코드 블록을 결정한다 조건식의 평가 결과가 true 일 경우 if 문의 코드 블록이 실행되고,false일경우 else 문의 코드가 실행
if(조건식){
    // 조건식이 참이면 이 코드 블록이 실행된다.
}else{
    // 조건식이 거짓이면 이 코드 블록이 실행된다.
}
// 조건식을 추가 하고 싶다면 else if 문을 사용한다 else는 한번만 쓸수있지만 else if 문은 여러번 호출 가능하다.
// 대부분의 if else 문은 상함 조건 연산자로 바꿔 쓸수 있다 
var x = 2;
var result;
if (x%2){
    result="홀수"
}else{
    result='짝수'
}
console.log(result); // 짝수
// 다음과 같이 삼항 조건 연산자로 바꿔 쓸 수 있다.
var x=2;
// 0은 false로 취급한다.
var result = x%2 ? '홀수':'짝수';
console.log(result);//짝수

// 위에 두가자 경우의 수(홀짝)를 갖는 경우다 만양 경우의 수가 세가지 (양수 음수 영)이라면 다음과 같이 바꿔쓸수 있다
var num =2;
var kind = num ?(num>0?'양수':'짝수'):'영';
console.log(kind)//양수

// 타입 변환
// 모든 값은 타입이 있다 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다.
// 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입변환 또는 타입 캐스팅이라 한다

var x= 10;
// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅한다
var str = x.toString()
console.log(typeof str,str);
// x변수의 값이 변경된 것은 아니다
console.log(typeof x,x); // number 10

// 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의헤 암묵적으로 타입이 자동 변환되기도 한다 이를 암묵적 타입변환
// 타입 강제 변환이라 한다

var x= 10;
// 암묵적 타입 변환 문자열 연결 연산자는 숫자 타입 x 의 값을 바탕으로 새ㅑ로운 문자열을 생성한다
var str = x + '';
console.log(typeof str,str); // string 10
// x변수의 값이 변경된 것은 아니다.
console.log(typeof x,x); // number 10

// 자바 스크립트 엔진은 표현식을 평가할때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환 할때가 있다
// 피연산자가 모두 문자열 타입이어야 하는 문맥
'10' + 2 // '102'
// 피연산자가 모두 숫자 타입이어야 하는 문맥
5*'10'// 50
// 피연산자 또는 표현식이 불리언 타입이어야 하는 문맥
!0// true
if(1){}
`1+1=${1+1}` //"1+1=2"

// 논리 연산자를 사용한 단축 평가
// 논리합 또는 논리곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다 논리합 논리곱 연산자 표현식은 언제나 2개의 피연산자
// 중 어느 한쪽으로 평가된다 라는 것이다.
'Cat' && 'Dog' // > Dog
// 논리곱 연산자는 두개의 피연산자가 모두 true 로 평가될때 true 를 반환한다 논리곱 연산자는 좌항에서 우항으로 평가가 진행된다
// 논리힙(||)연산자도 논리곱(&&)연산자와 동일하게 동작한다
'Cat' && 'Dog' // > Cat
// 논리합 연산자는 두 개의 피연산자 중 하나만 true 로 평가되어도 true 를 반환한다. 논리합 연산자도 좌항에서 우항으로 평가가 진행된다
// 논리합 연산자는 2번째 평가해 보지 않아도 위 표현식을 평가할 수 있다 논리 연산의 결과를 결정한 첫 번째 피연산자, 즉 문자열 'Cat' 을 그대로 반환한다
// 논리곱 연산자는 논리합 연산자는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다. 이를 단축 평가라한다
// 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다
// 논리합(||)연산자
'cat' || 'dog' // cat
false || 'dog' // dog
'cat' || false // cat
// 논리곱(&&) 연산자
'cat' && 'dog' // dog
false && 'dog' // false
'cat' && false // false

// 단축 평가를 사용하면 if문을 대체할수 있다 어떤 조건이 Truthy 값(참으로 평가되는 값) 일 떼 무언가를 해야한다면 논리곱 연산자 표현식으로
// if문을 대체할 수 있다
var done= true;
var message = '';

// 주어진 조건이 true 일 때
if(done) message='완료';
// if 문은 단축 평가로 대체 가능하다.
// done이 true 라면 message 에 '완료'를 할당
message = done && '완료';
console.log(message);//완료
// 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야한다면 논리합(||) 연산자 표현식으로 if문을 대체할수 있다
var done=false;
var message = '';

// 주어진 조건이 false 일 때
if(!done)message = '미완료';
// if 문은 단축 평가로 대체 가능하다.
// done이 false 라면 message에 '미완료'를 할당
message = done || '미완료';
console.log(message);// 미완료

// 삼항 조건 연산자는 if else 문을 대체할 수 있다
var done = true
var message = '';

if(done)message='완료';
else    message='미완료';
console.log(message);// 완료
message = done ? '완료':'미완료';
console.log(message);// 완료

// 객체를 가리키기를 기대하는 변수가 null 또는 undefined 가 아닌지 확인하고 프로퍼티를 참조할 때
// 객체는 키와 값으로 구성된 프로퍼티의 집합이다 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null 또는 undefind
// 인 경우 객체의 프로퍼티를 참조하면 타입 에러가 발생한다 프로그램 강제 종료
var elem = null;
// elem 이 null 이나 undefind 와 같은 falsy 값이면 elem 으로 평가되고
// elem 이 truthy 값이면 elem.value 로 평가된다
var value = elem && elem.value; // null