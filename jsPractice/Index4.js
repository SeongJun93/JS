/*원시값과 객채의비교

원시타입은 원시타입값 즉 원시 값은 변경 불가능한 값이다 이에 비해 객체타입의 값 즉 객체는 변경 가능한 값이다
원시 값을 변수에 할당하면 변수 에는 실제 값잉 저장된다 객체를 변수에 할당하면 변수에는 참조 값이 저장된다

즉 원시값은 변경불가능해도 변수 값을 변경 불가능하다는 것은 아니다
*/

const o = {};
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다 상수는 재할당이 금지된 변수일 뿐이다.
// const 키워드를 사용해 선언한 변수에 할당한 원시 값(상수)는 변경할수 없다
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a =1;
console.log(o); //{a:1}

/** 
 * 원시값은 변경 불가능한 값이기 때문에 값을 직접 변경할수 없다 따라서 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 매모리 공간을
 * 확보하고 재할당한 값을 저장한 후 변수가 참조하던 메모리 공간의 주소를 변경한다 이러한 특성을 분별성이라 한다.
*/

// 문자열은 0개 이상의 문자로 이뤄진 집합이다.
var str1= ''; // 0개의 문자로 이뤄진 문자열(빈 문자열)
var str2= 'Hello' // 5개의 문자로 이뤄진 문자열

var str='string'
// 문자열을 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다
console.log(str[0]);//5
// 원시 값인 문자열이 객체처럼 동작한다
console.log(str.length);//6
console.log(str.toUpperCase());//string

var str='string';
str[0]='S';
console.log(str)//s
// 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다 문자열은 변경 불가능한 값이기 때문에 원시값은 어떤일이 있어도 분변한다 이는 데이터의 신뢰성을 보장한다
// 그러나 변수에 샤로운 문자열을 재할당하는 것을 물론 가능하다 이는 기존 문자열을 변경하는 것이 아니라
// 새로운 문자열을 새롭게 할당하는 것이기 때문이다.

var score=80;
var copy=score;

console.log(score) //80
console.log(copy) //80

score=100;

console.log(score) //100
console.log(copy)// ?

// 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다 하지만 객체는 변경 가능한 값이다
// 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다 즉 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을
// 갱신할 수도 있으면 프로퍼티 자체를 삭제할 수ㄷㅎ 았다
var person = {
    name:'Lee'
};
// 프로퍼티 값 갱신
person.name = 'Kim';
// 프로퍼티 동적 생성
person.address = "Seoul";
console.log(person); // {name:"Kim",address:"Seoul"}
// 원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당을 통해 메모리의 원시 값을 새롭게 생성해야 한다
// 하지만 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정하할 수 있다 이때 객체를 할당한 변수에 재할당을 하지 않았으므로
// 객체를 할당한 변수의 참조 값은 변경되지 않는다.

// 함수 수학의 함수는 입력을 받아 출력을 내보내는 일련의 과정을 정의한 것이다 예를 들어. f(x.y)=x+y 라는 함수를 정의하고 이 함수에
// 두 개의 입력 2.5 를 전달하면 함수는 정의된 일련의 과정 즉 x+y를 실행하여 7을 출력 이처럼 함수는 재료를 투입받아 제품을 생산하는것과 같다
function add(x,y){
    return x+y;
}
add(2, 5) //7
// 함수 호출 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 싱행되고 실행결과 즉 반환값을 반환한다.
var result = add(2,5)
console.log(result)// 7

// 함수를 사용하는 이유는 코드의 재사용성이라는 측면이 매우 유용하기 때문
// 코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.
// 코드는 동작하는 것만이 존재 목적은 아니다 코드는 개발자를 위한 문서이기도 하다 따라서 사람이 이해할수 있는 코드 즉 가독성이 좋은 코드가 좋은 코드다

// 화살표 함수
const add =(x, y) => x+y;
console.log(add(2,5))  // 7
function add(x,y){
    return x+y;
}
console.log(add(2)) // NaN
console.log(add('a','b')) // 'ab'

// 자바스크립트는 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다
// 자바스크립트는 동적 타입 언어다 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.
// 따라서 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되어있는지 확인할 필요가 있다

// 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다
$.ajax({
    method:'POST',
    url:'/user',
    data:{id:1,name:'Lee'},
    cache:false
})

// 반환문
// 함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행결과를 함수 외부로 반환 할 수 있다.
function multiply(x, y){
    return x+y; // 반환문
}

// 함수 호출은 반환값으로 평가된다.
var result = multiply(3,5);
console.log(result); // 15
// 함수 호출은 표현식이다 함수 호출 표현식은 return 키워드가 반환된 표현식의 평가 결과. 즉 반환값으로 평가된다.

function multiply(x, y){
    return x+y; // 반환문
    // 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
    console.log('실행되지 않는다')
}
console.log(multiply(3,5)); // 15

function foo(){
    return ;
}
console.log(foo()) //undefind
// 반환문은 생략할 수 있다 이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefind 를 반환한다

function foo(){
    // 반환문을 생력하면 암묵적으로 undefind 가 반환된다
}
console.log(foo)// undefind

function multiply(x, y){
    return // 세미클론 자동 삽입 기능에 의해 세미콜론 이 추가된다
    x*y// 무시된다
}
console.log(multiply(3,5)); // 15

// 반환문은 함수 몸체 내부에서만 사용할 수 있다 전역에서 반환문을 사용하면 문법 에러가 발생한다
// 참고로 node.js 는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갖는다 node.js 환경에서는 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다

function countdown(){
    for(var i=n; i>=0;i--)console.log(i)
}
countdown(10);
// 위 함수는 잘 작동된다 하지만 반복문을 작성하지 않고도 사용할수 있는 방법이 있다 바로 재귀함수를 사용한다

function countdown(){
    if(n<0) return;
    console.log(n);
    countdown(n-1)// 재귀 호출
}
countdown(10);
// 재귀 함수는 자신을 무한 재귀 호출한다 따라서 재귀 함수 내에는 제귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다

// 스코프 
// 스코프란 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적아며 중요한 개념이다
// 또한 var.const,let 키워드로 선언한 변수의 스코프도 다르게 동작한다 스코프는 함수와 변수에 깊은 관련이 있다.

function add(x,y){
    // 매개변수는 함수 몸체 내부에서만 참조할 수 있다
    // 즉 매개변수의 스코프(유효범위)는 함수 몸체 내부다
    console.log(x,y); //2,5
    return x+y;
}
add(2,5)
// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x,y) // 리퍼런스 에러 이즈 낫 디파인드

// 모든 식별자 (변수이름, 함수 이름, 클래스 이름등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할수 있는 유효범위가
// 결정된다 이를 스코프라 한다 즉 스코프는 식별자가 유효한 범위를 말한다.

// let const 로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용되지 않는다.

// 스코프의 종류 
// 코드는 전역과 지역으로 구분할 수 있다.

// 전역변수의 문제점
// 생명주기가 길다 메모리 리소스도 오랜 기간 소비한다 전역 변수의 상태를 변경 할 수 있는 기간도 길고 기회도 많다
// 또힌 var 는 의도치 않은 재할당도 일어난다

// 전역 변수의 사용을 억제하는 방법
// 전역 변수를 반드시 사용해야할 이유를 찾지 못한다면 지역 변수를 사용해야 한다 변수의 스코프는 좁을수록 좋다.

// 네임스페이스 객체
var MYAPP = {} //전역 네임스페이스 객체
MYAPP.name = "Lee";
console.log(MYAPP.name);//Lee

var MYAPP = {}
    MYAPP.person={
        name:"Lee",
        address:"Seoul"
    }
console.log(MYAPP.person.name); //Lee

// 모듈 패턴
// 모듈패턴의 특징은 전역변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다.
// 캡슐화는 객체의 상테를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작 인 메서드를 하나로 묶는 것을 말한다.
// 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라한다
// 대부분의 객체지향 프로그래밍 언어는 클래스를 구성하는 맴버에 대해 public,private,protected 등의 접근제한자를 통해
// 공개범위를 한정한다
// 하지만 자바스크립트는 위에 접근 제한자를 제공하지 않는다 모듈패턴은 전역 네임스페이스의 오염을 막는 기능은 물론
// 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용한다

var Counter = (function(){
    //Private 변수
    var num = 0;
    // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다
    return{
        increase(){
            return ++num;
        },
        decrease(){
            return --num;
        }
    }
}());

// let ,const 키워드와 블록레벨 스코프
// 변수 중복 선언 허용
// var 키워드로 선언한 변수는 재할당이 가능해 중복선언이 가능하다.
// for 문 if 문에서 사용한 var 변수또한 재할당되어 문제를 야기 할 수 있다.

// let 키워드
// let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다

let bar = 123;
let bar = 456; // 에러

let foo = 1; // 전역 변수
{
    let foo = 2; //지역 변수
    let bar = 3; //지역 변수
}
console.log(foo) //1 
console.log(bar) // 에러
